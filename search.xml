<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目技术点记录（flask项目、vue前端、跨域、python网络编程）</title>
      <link href="/2019/04/02/project/"/>
      <url>/2019/04/02/project/</url>
      
        <content type="html"><![CDATA[<p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p>搏一搏，单车变摩托~</p><h2 id="DRASP：基于PHP内核扩展的web程序运行时自保护系统"><a href="#DRASP：基于PHP内核扩展的web程序运行时自保护系统" class="headerlink" title="DRASP：基于PHP内核扩展的web程序运行时自保护系统"></a>DRASP：基于PHP内核扩展的web程序运行时自保护系统</h2><ul><li>后端flask的装饰器路由等</li><li>前端ajax数据交互</li><li>获取当前登录的用户cookie 设置cookie 获取cookie</li><li>根据ip获取城市名（淘宝接口）</li></ul><p>基于PHP内核扩展的web程序运行时自保护系统，在Linux服务器端部署探针程序之后，能够针对相应php或者包含php脚本页面的访问进行检测、记录并拦截恶意请求，将请求发送到日志服务器，达到过滤不良信息与保护服务器端的效果。同时，在本系统日志展示界平台上，用户在登录其账户之后，能够添加服务器并显示检测信息，日志信息展示界面上还提供了丰富的图表展示，能够给用户更加直观、具体的数据报告，不仅对用户的服务器安全给出了形象的描述而且为日后用户修改服务器上php文件提供了指导。</p><h3 id="后端flask"><a href="#后端flask" class="headerlink" title="后端flask:"></a><strong>后端flask:</strong></h3><p>装饰器app.route ：处理URL和函数之间的关系的程序称之为路由，使用程序实例提供的app.route修饰器，把修饰的函数注册为路由。</p><p>路由：路由就是将URL绑定到一个函数上面，这样浏览器客户端向web服务器发送一个URL请求后，服务器中的路由收到这个URL后，能立马找到对应的函数进行处理。</p><p><strong>前端：</strong></p><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax:"></a><strong>ajax:</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加服务器--&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData_server_ip</span>(<span class="params">inputValue</span>)</span>&#123;</span><br><span class="line">       $.ajax(&#123;</span><br><span class="line">           url: <span class="string">'/api/server_add'</span>,</span><br><span class="line">           type: <span class="string">'POST'</span>,</span><br><span class="line">           data: &#123;<span class="string">'ip'</span>: inputValue&#125;,</span><br><span class="line">           anync: <span class="literal">true</span>,</span><br><span class="line">           dataType: <span class="string">'json'</span>,</span><br><span class="line">           success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                   <span class="keyword">var</span> popContent =[</span><br><span class="line">                     <span class="string">'&lt;li class="server-li"&gt;'</span>,</span><br><span class="line">                     <span class="string">'&lt;span class="server-text"&gt;'</span>+inputValue+<span class="string">'&lt;/span&gt;'</span>,</span><br><span class="line">                     <span class="string">'&lt;input type="button" class="server-btn" value="show" server="'</span>+inputValue+<span class="string">'" onclick="btn(\''</span>+inputValue+<span class="string">'\')"&gt;'</span>,</span><br><span class="line">                     <span class="string">'&lt;/li&gt;'</span></span><br><span class="line">                       ].join(<span class="string">' '</span>);</span><br><span class="line">                   $(<span class="string">'#server-ul'</span>).append(popContent);</span><br><span class="line">           &#125;,</span><br><span class="line">           error: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">               alert(<span class="string">"ajax连接异常："</span>+msg);</span><br><span class="line">           &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><h3 id="获取用户名：（以登录为例）"><a href="#获取用户名：（以登录为例）" class="headerlink" title="获取用户名：（以登录为例）"></a>获取用户名：（以登录为例）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    session = DBSession()</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">'login.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = request.form.get(<span class="string">'user-login'</span>)</span><br><span class="line">        pw = request.form.get(<span class="string">'pw-login'</span>)</span><br><span class="line">        user = session.query(User).filter(User.username == username).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">if</span> session.query(User).filter(User.pw == pw).first():</span><br><span class="line">                response = make_response(redirect(url_for(<span class="string">'index'</span>, username=username)))</span><br><span class="line">                response.set_cookie(key=<span class="string">"name"</span>,value=username)  <span class="comment"># 设置cookie</span></span><br><span class="line">                <span class="keyword">return</span> response</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flash(<span class="string">'密码错误 ！'</span>)</span><br><span class="line">                <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flash(<span class="string">'用户名不存在 ！'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'login'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 饼状图</span></span><br><span class="line"><span class="meta">@app.route('/api/pie', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pie_data</span><span class="params">()</span>:</span></span><br><span class="line">    username = request.cookies.get(<span class="string">"name"</span>)  <span class="comment"># 获取cookie</span></span><br><span class="line">    host = request.form.get(<span class="string">'host'</span>)  <span class="comment"># 获取当前主机</span></span><br><span class="line">    <span class="keyword">if</span> host:  // 执行sql语句</span><br><span class="line">        cur = engine.execute(<span class="string">"select type, count(type) as num from log where username='"</span>+username+<span class="string">"' and server='"</span>+host+<span class="string">"' and intercept='attack' group by type"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur = engine.execute(<span class="string">"select type, count(type) as num from log where username='"</span> + username + <span class="string">"' and intercept='attack' group by type"</span>)</span><br><span class="line">    pie_data = cur.fetchall()  <span class="comment"># 返回多个元组（记录）</span></span><br><span class="line"></span><br><span class="line">    jsonData = &#123;&#125;  <span class="comment"># 字典</span></span><br><span class="line">    type = []</span><br><span class="line">    num = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> pie_data:</span><br><span class="line">        type.append(item[<span class="number">0</span>])</span><br><span class="line">        num.append(dict(value=item[<span class="number">1</span>], name=item[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    jsonData[<span class="string">'type'</span>] = type</span><br><span class="line">    jsonData[<span class="string">'num'</span>] = num</span><br><span class="line">    data = json.dumps(jsonData) <span class="comment">#json.dumps()用于将dict类型的数据转成str loads是相反的操作</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><h3 id="通过ip获取城市名称："><a href="#通过ip获取城市名称：" class="headerlink" title="通过ip获取城市名称："></a>通过ip获取城市名称：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过ip获取城市名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ip2location</span><span class="params">(ip=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.get(url=<span class="string">"http://ip.taobao.com/service/getIpInfo.php?ip=%s"</span> % ip, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">            data = json.loads(res.text)[<span class="string">"data"</span>] <span class="comment"># data是返回的json字符串，只提取其中的city选项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"%s"</span> % (data[<span class="string">"city"</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"接口炸了"</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(url=<span class="string">"http://ip.taobao.com/service/getIpInfo.php?ip=%s"</span> % ip, timeout=<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                data = json.loads(res.text)[<span class="string">"data"</span>]</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"%s"</span> % (data[<span class="string">"city"</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"接口炸了"</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"接口炸了"</span></span><br><span class="line"><span class="comment"># 多次获取，防止接口炸了</span></span><br></pre></td></tr></table></figure><h2 id="签到平台前端VUE-JS"><a href="#签到平台前端VUE-JS" class="headerlink" title="签到平台前端VUE.JS"></a>签到平台前端VUE.JS</h2><h3 id="跨域问题（Django）"><a href="#跨域问题（Django）" class="headerlink" title="跨域问题（Django）"></a>跨域问题（Django）</h3><p>在看到跨域问题时，曾屡次考虑是自己前端的锅，后来才发现是后端的问题</p><p>使用django的插件来解决 django-cors-headers，只需要简单的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install django-cors-headers</span><br><span class="line"><span class="comment"># 添加应用</span></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'corsheaders'</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 中间层设置  注意顺序问题放在最前的位置</span></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'corsheaders.middleware.CorsMiddleware'</span>,</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"><span class="comment"># 添加白名单</span></span><br><span class="line"><span class="comment"># CORS</span></span><br><span class="line">CORS_ORIGIN_WHITELIST = (</span><br><span class="line">    <span class="comment"># 跨域的域名</span></span><br><span class="line">)</span><br><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span>  <span class="comment"># 允许携带cookie</span></span><br><span class="line"><span class="comment"># 凡是出现在白名单中的域名，都可以访问后端接口</span></span><br><span class="line"><span class="comment"># CORS_ALLOW_CREDENTIALS 指明在跨域访问中，后端是否支持对cookie的操作。</span></span><br></pre></td></tr></table></figure><h2 id="新闻平台"><a href="#新闻平台" class="headerlink" title="新闻平台"></a>新闻平台</h2><h3 id="前后端分离的架构模式"><a href="#前后端分离的架构模式" class="headerlink" title="前后端分离的架构模式"></a>前后端分离的架构模式</h3><p>核心思想：前端html页面通过ajax调用后端的api接口并使用json进行数据交互</p><p>以前的开发模式前后端依赖比较强，前端写好html之后后端才能套jsp，但是前后端分离的方式则是前后端约定接口数据参数，然后前后端就可以并行开发开发效率高，无强依赖，前端控制路由和渲染界面，整个项目开发权重取前移。在大并发的情况下可以同时水平扩展前后端服务器，减少了后端服务器并发负载的压力，除了接口以外的其他所有http请求全部转移到前端nginx上。</p><p><a href="https://blog.csdn.net/dream_cat_forever/article/details/80709503#commentBox" target="_blank" rel="noopener">参考</a></p><h2 id="Java跨域"><a href="#Java跨域" class="headerlink" title="Java跨域"></a>Java跨域</h2><p>在代码中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>,request.getHeader(<span class="string">"origin"</span>));<span class="comment">//表示接受任何域名的请求</span></span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);  <span class="comment">//是否允许发送cookie</span></span><br></pre></td></tr></table></figure><h2 id="python网络编程"><a href="#python网络编程" class="headerlink" title="python网络编程"></a>python网络编程</h2><p>详见 <a href="https://github.com/slyslyme/python-socket" target="_blank" rel="noopener">github</a> </p><p>实现了文件上传、文件下载、远程命令行执行（客户端发送命令到服务端执行）。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
            <tag> flask </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2019/03/25/%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/25/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p>8天后的ByteDance</p><p>已经写过的代码：</p><p>实现一个hashtable</p><p>写一个二叉树，每个节点除了有左右子节点外，还有指向父节点的引用，给出一个节点，返回它在二叉树中序遍历的下一个节点</p><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次（使用递归或者遍历）</p><p>给定一个二叉树，原地将他展开成为链表</p><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p>合并两个有序链表。递归和非递归的实现。</p><p>给定一颗二叉树，求其中root的最长路径。所谓路径是指，联通两个结点的最小边数</p><p>来一道算法题，删除链表重复节点</p><p>给一个字符串str，打印出这个文件夹的文件结构（参考linux命令tree） 用一个递归能写出来<br>给一个有序序列，又给了这些数字两个数字在一起的分组，调整后必须使得一个组的两个数字挨着，最少交换几次数字   这个到最后也没写出来，然后二面告诉我说也是用递归实现</p><p>编程题：建堆过程</p><p>编程题：最小栈：在O(1)的时间复杂度内返回栈的最小元素。思路：两个栈，一个栈模拟普通的push、pop，getMin() 操作，一个栈用于存储最小值序列。</p><p> 编程题：数组中除了两个数，其他树都出现偶数次，找出这两个只出现一次的数。二面我就答上来这一道题，哭惹</p><p> 编程题：二叉树转双端链表，半个小时没写出来，，，</p><p>一开始写算法，爬楼梯，一次只能爬一阶或两阶，n阶楼梯共几种爬法。（写递归，非递归，还有复杂度为（logn）三种，第三种我写不出来）</p><p>数据结构，有（0-9亿）条数据，支持FIFO、LIFO，4G memory。要求动态设定长度，不能超出内存限制。<br> 算法题：二维数组，从左到右升序，从上到下降序，查找某个元素是否存在。（由于秒解，面试官：之前是不是做过？ 我：。。。）  </p><p> 写代码，s型打印二叉树。就是按层次遍历，不过是一层从左到右，下一层从右到左这样。</p><p>算法： </p><ol start="7"><li><p>输出二叉搜索树第k小节点值。（说思路）</p><ol start="8"><li><p>输入两个链表，找出它们的第一个公共结点。（说思路）</p></li><li><p>字符串中最长的连续不重复子串（子串中不含重复字符），要求O(n)时间。（说思路，写代码）。</p></li></ol></li></ol><p>算法题：栈逆序，给一个空栈，若干变量，把1-10变成10-1，如果要优化你的代码，怎么优化。</p><p>了解排序么，答：快排 归并 选择 冒泡 桶排序啥的。</p><p>然后才知道top n 是要问排序，就说用桶排序查。</p><p>桶排序复杂度，用大顶堆还是小顶堆做——大顶堆。</p><p>算法题，括号匹配</p><p>上来先撸了三道题：<br> \1. 给定字符串，求最大不重复子串长度（秒了）<br> \2. 2 个人玩游戏，每局获胜的概率都是 50%，A 赢 3 次胜利，B 赢 2 次胜利，求 A B 的获胜概率（就是一个状态转移问题，画了图，秒掉）<br> \3. 两个字符串的最大子序列长度（这个面试官只让我说了思路，动态规划秒掉）   </p><p>写反转链表</p><p>让写一个最大公共子串，我函数写混了，小姐姐那边关了摄像头一直发出笑声。。。真的颤抖</p><p>\8. 编程题：建堆过程</p><p>\9. 编程题：最小栈：在O(1)的时间复杂度内返回栈的最小元素。思路：两个栈，一个栈模拟普通的push、pop，getMin() 操作，一个栈用于存储最小值序列。</p><p>\5. 编程题：数组中除了两个数，其他树都出现偶数次，找出这两个只出现一次的数。二面我就答上来这一道题，哭惹</p><p>\6. 编程题：二叉树转双端链表，半个小时没写出来，，，</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java框架学习 ๑╹◡╹)ﾉ”  [spring]</title>
      <link href="/2019/03/10/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%5Bspring%5D1/"/>
      <url>/2019/03/10/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%5Bspring%5D1/</url>
      
        <content type="html"><![CDATA[<p>Java框架学习之路</p><p><img src="https://ww4.sinaimg.cn/bmiddle/005yPOQzly1g0xhzgmagdj30u01hctwf.jpg" alt="img"></p><p>#### </p><h2 id="介绍spring"><a href="#介绍spring" class="headerlink" title="介绍spring"></a>介绍spring</h2><p>90.为什么要使用 spring？</p><p>91.解释一下什么是 aop？</p><p>92.解释一下什么是 ioc？</p><p>93.spring 有哪些主要模块？</p><p>94.spring 常用的注入方式有哪些？</p><p>95.spring 中的 bean 是线程安全的吗？</p><p>96.spring 支持几种 bean 的作用域？</p><p>97.spring 自动装配 bean 有哪些方式？</p><p>98.spring 事务实现方式有哪些？</p><p>99.说一下 spring 的事务隔离？</p><p>100.说一下 spring mvc 运行流程？</p><p>101.spring mvc 有哪些组件？</p><p>102.@RequestMapping 的作用是什么？</p><p>103.@Autowired 的作用是什么？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端学习✧(≖ ◡ ≖✿</title>
      <link href="/2019/03/09/Java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/03/09/Java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>哦天哪 心动女生~~~~</p><p><img src="https://wx2.sinaimg.cn/mw690/006aNohggy1g0u4bqdhu6j30u0140wnj.jpg" alt="img"></p><h2 id="Java基础篇"><a href="#Java基础篇" class="headerlink" title="Java基础篇"></a>Java基础篇</h2><p>一、JDK和JRE有什么区别</p><p>JRE是Java程序的运行环境，核心内容是JVM和一些核心类库，主要面向程序使用者。</p><p>JDK是Java的开发工具包，包含各种类库和工具，主要面向开发人员，提供开发环境和运行环境。</p><p>二、 == 和equals的区别是什么</p><ol><li><p>== 比较内存地址的数值,也就是比较是否是同一个地址,即是否是同一个对象</p></li><li><p>equals通过重写用来比较两个字符串内容是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">String str3 = str2;</span><br><span class="line">System.out.println(str1==str2);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str1==str3);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str3==str2);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.</p></li><li><p>栈(stack)：存放<strong>基本类型的变量数据</strong>和<strong>对象的引用</strong>，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）</p></li><li>堆(heap)：存放所有<strong>new出来的对象</strong>。</li><li>静态域：存放静态成员（static定义的）。</li><li>常量池：存放字符串常量和基本类型常量（public static final），常量池位于堆中。</li><li>非RAM存储：硬盘等永久存储空间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"china"</span>;  </span><br><span class="line">String s2 = <span class="string">"china"</span>;  </span><br><span class="line">String s3 = <span class="string">"china"</span>;  </span><br><span class="line">String ss1 = <span class="keyword">new</span> String(<span class="string">"china"</span>);  </span><br><span class="line">String ss2 = <span class="keyword">new</span> String(<span class="string">"china"</span>);  </span><br><span class="line">String ss3 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</span><br></pre></td></tr></table></figure><p>s1 s2 s2存在与栈中，ss1 ss2 ss3是new出来的对象，其对象的引用（即对象在堆内存中的地址）存在栈中，“china”这个常量存在与常量池中</p><p><img src="http://dl.iteye.com/upload/attachment/331454/3588b3c6-f37b-3d63-a48f-59134ea691d2.png" alt="img"></p><p>下黄色这3个箭头，对于通过new产生一个字符串（假设为”china”）时，会先去常量池中查找是否已经有了”china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。这也就是有道面试题：String s = new String(“china”);产生几个对象？一个或两个，如果常量池中原来没有”china”,就是两个。</p><p>对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。</p><p><strong>关于Java中的堆和栈：</strong></p><p>栈中的数据和堆中的数据销毁并不是同步的。每个方法在执行时都会建立自己的栈区，方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收才可以被销毁，这个是由JVM决定的。 </p><p>对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。</p><p>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。</p><p>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>三、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</p><p>不一定。反过来也是不一定的。</p><p>hashCode()是返回哈希码，是对象在哈希表中的索引</p><p>关于Java规范：</p><p>规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该 相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。<br>规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。</p><p>自己的理解：在哈希表中的键值对，键不同值可能相同，所以hashCode()相同，其对象并不一定相等。</p><p>四、final 在 java 中有什么作用？</p><p>final修饰的变量，变量的值不能被修改，是常量，在声明的同时需要进行初始化。final 修饰的类不允许进行继承。final修饰的方法不能被重写。</p><p>五、java 中的 Math.round(-1.5) 等于多少？</p><p>-1</p><p>参数的小数部分大于0.5或者小于0.5，在根据绝对值进行四舍五入，如果刚好等于0.5，则舍入到正无穷+∞方向。</p><p>比如Math.round(-1.5)=-1  Math.round(1.5)=2  Math.round(-1.4)=-1  Math.round(-1.6)=-2  Math.round(1.6)=2  </p><p>六、String 属于基础的数据类型吗？</p><p>不属于。</p><p>Java中基本的数据类型是int(32)  float(32)  double(64)  char(16)  byte(8)   boolean(1)   short(16)   long(64)</p><p>String在定义中是final类，属于引用数据类型，变量名指向存数据对象的内存地址。即变量名指向hash</p><p>七、java 中操作字符串都有哪些类？它们之间有什么区别？</p><p>String  stringBuffer stringBuilder</p><ol><li>String</li></ol><p>String 对象创建后则不能被修改，是<strong>不可变</strong>的，在定义中是<strong>final类</strong>，其对String操作的方法在定义中也是生成新的对象，所谓的修改其实是创建了新的对象，所指向的<strong>内存空间不同</strong>。</p><p><strong>注意</strong>：Object类中equal()方法比较的是对象的引用是否指向同一块内存地址，而String类中equals(): 比较存储在两个字符串对象中的内容是否一致。<strong>Object类中是equal()方法；String类中是equals()，差了一个s。</strong></p><p>String的操作是改变复制地址并不是改变值</p><ol start="2"><li>StringBuffer</li></ol><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p><p>　　　　<strong>char[] value;</strong></p><p>StringBuffer类的方法是多线程、安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。<strong>对于经常要改变值的字符串应该使用StringBuffer和StringBuilder类。</strong></p><ol start="3"><li>StringBuilder</li></ol><p>单线程下使用stringBuilder效率更高</p><p>一般情况下执行效率： StringBuilder &gt; StringBuffer &gt; String</p><p>八、String str=”i”与 String str=new String(“i”)一样吗？</p><p>不一样。对于直接使用赋值法创建的字符串，如果内存常量池中已经为“i”分配了内存，那么str就指向”i“内存对象的地址。使用第二种new出来的字符串，不管常量池中有没有”i“都会在堆中重新分配一个内存区域来存放”i“，然后str指向它，相当于内存（堆）中有两个”i“,只是存放地址不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"hello world"</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">        String str3 = <span class="string">"hello world"</span>;</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(str1==str2);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(str1==str3);  <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2==str4);  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       关于JVM内存机制 ，在class文件中有一部分 来存储编译期间生成的 <strong>字面常量</strong>以及<strong>符号引用</strong>，这部分叫做class文件常量池，在运行期间对应着方法区的运行时<strong>常量池</strong>。</p><p>　　因此在上述代码中，String str1 = “hello world”;和String str3 = “hello world”; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量”hello world”被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时<strong>常量池查找是否存在相同的字面常量</strong>，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。</p><p>　　总所周知，通过<strong>new关键字来生成对象是在堆区</strong>进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello"</span>;</span><br><span class="line">        String b =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String c =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String d = b.intern();</span><br><span class="line">         </span><br><span class="line">        System.out.println(a==b); <span class="comment">// false</span></span><br><span class="line">        System.out.println(b==c); <span class="comment">// false</span></span><br><span class="line">        System.out.println(b==d); <span class="comment">// false</span></span><br><span class="line">        System.out.println(a==d); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。</p><p>九、如何将字符串反转</p><p>递归String left= s.substring(0, length/2); String right = s.substring(length / 2, length); return reverse1(right)+reverse1(left);  // 关于substring是截取函数</p><p>使用StringBuffer()中的reserve方法：new StringBuffer(s).reverse().toString();</p><p>分解字符串单个字符拼接/利用charAt（）</p><p>字符串首位对调位置</p><p>十、String类的常用方法有哪些</p><p>int .length() 字符串的长度</p><p>boolean .equals(String s) 比较字符串试题是否相等</p><p>int compareTo(String s)按照字典序和S进行比较大小，大于S返回正值</p><p>boolean contains(String s) 判断当前字符串对象是否含有s</p><p>int indexOf(String s) 返回位置索引，没有就返回负数</p><p>String trim() 去掉字符串前后空格</p><p>String substring(int start, int end) 返回子串</p><p>基本数据类型的相互转化：</p><p>int parseInt(String s)  或者short long Float等</p><p>对象的字符串表示：</p><p>String toString()  可以对这个方法进行重写</p><p>StringBuffer类，创建的是可修改的字符串序列，可以使用append进行追加</p><p>char charAt(int n) 得到参数n位置上的单个字符</p><p>void setCharAt(int n, char ch) 将N处的字符串进行替换</p><p>十一、抽象类必须要有抽象方法吗？</p><p>不是必须的。抽象类和普通类相比就是多了抽象方法， 抽象类中可以没有抽象方法，但是抽象方法一定要在抽象类中。抽象类不能使用new运算符创建对象。如果一个非抽象类是抽象类的子类，那么他一定要重写父类的抽象方法，给出方法，所以不能用final 和static同时修饰一个方法。</p><p>十二、普通类和抽象类有哪些区别？</p><ol><li>抽象类不能被实例化（不能用new创建对象）需要进行重写</li><li>抽象类中可以有抽象方法</li><li>抽象类中的抽象方法没有方法体</li><li>抽象类的非抽象子类必须重写抽象类的全部抽象方法，如果没有，那么子类也必须定义为抽象类</li></ol><p>十三、抽象类能使用 final 修饰吗？</p><p>不能，final修饰的类无法继承</p><p>十四、接口和抽象类有什么区别？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式【One design pattern a day】 (o(*ﾟ▽ﾟ*)o)♡</title>
      <link href="/2019/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%90One-design-pattern-a-day%E3%80%91-(o(%EF%BE%9F%E2%96%BD%EF%BE%9F)o)%E2%99%A1/"/>
      <url>/2019/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%90One-design-pattern-a-day%E3%80%91-(o(%EF%BE%9F%E2%96%BD%EF%BE%9F)o)%E2%99%A1/</url>
      
        <content type="html"><![CDATA[<p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p>介个设计模式是上个学期实验室大神建议看的，结果拖着又懒一直没看，一天一个给补上吧吼吼~~</p><ol><li>工厂模式 池子 连接池</li><li>单例模式  饿汉模式 懒汉模式</li><li>适配器模式 过滤器 装饰器 （Java Web)</li><li>迭代器</li><li>模板模式 </li><li>状态模式</li><li>MVC （model模型 数据层     view视图层 渲染界面  coltroller 控制器 业务逻辑）</li></ol><p><img src="https://ww3.sinaimg.cn/bmiddle/007Bs6V5ly1g0o7v6j0ypj30b40b4t9h.jpg" alt="img"></p><h2 id="前言-what-is-the-设计模式"><a href="#前言-what-is-the-设计模式" class="headerlink" title="前言-what is the 设计模式"></a>前言-what is the 设计模式</h2><p>1.设计模式是解决方案</p><p>2.设计模式是特定问题的解决方案</p><p>3.设计模式是重复出现的、特定问题的解决方案</p><p>4.设计模式是用于解决在特定环境下、重复出现的、特定问题的解决方案</p><p>5.设计模式是经过验证的，用于解决在特定环境下、重复出现的、特定问题的解决方案</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><a href="http://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">参考学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git总结   ฅ^•ﻌ•^ฅ</title>
      <link href="/2019/03/02/git%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/02/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>﻿ε≡٩(๑&gt;₃&lt;)۶ 一心向学…</p><p>φ(๑˃∀˂๑)♪ 学习是我的全部</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><em>:ஐ٩(๑´ᵕ`)۶ஐ:</em> 学习使我进步</p><p>*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p>今天是三月二号嘤~ </p><p>总结一下git的工作原理，以及使用git的基本命令</p><p><img src="https://ww3.sinaimg.cn/thumb150/006tKWBYgy1g0nqzo2ipdj30b40b4jrz.jpg" alt="img"></p><p><img src="https://ww1.sinaimg.cn/bmiddle/0071folOly1g0njusl3kuj31731734ee.jpg" alt="你只配看本学霸背影"></p><h1 id="Git猫粮"><a href="#Git猫粮" class="headerlink" title="Git猫粮"></a>Git猫粮</h1><p>有git使用经验，并对git工作流程有所了解.</p><h3 id="什么是版本控制系统："><a href="#什么是版本控制系统：" class="headerlink" title="什么是版本控制系统："></a>什么是版本控制系统：</h3><p>维基百科的解释：版本控制（Revision control）是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软体工程技巧，借此能在软体开发的过程中，确保由不同人所编辑的同一程式档案都得到同步。</p><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="git与其他版本版本控制系统的差异："><a href="#git与其他版本版本控制系统的差异：" class="headerlink" title="git与其他版本版本控制系统的差异："></a>git与其他版本版本控制系统的差异：</h3><p>CVS Subversion Perforce Bazaar等系统以文件变更列表的方式存储信息，这类系统保存的信息看作是一组基本文件和每个文件随时间逐步积累的差异。存储每个文件与原始版本的差异。</p><p>Git主要是对当时的全部文件制作一个快照并保存这个快照的索引。如果文件没有修改，git不再重新存储该文件，而只是保留一个链接指向之前存储的文件。Git更像是把数据看作是对小型文件系统的一组快照</p><h3 id="git的三种状态："><a href="#git的三种状态：" class="headerlink" title="git的三种状态："></a>git的三种状态：</h3><p>Git 有三种状态：已提交(committed)、已修改(modified)和已暂存(staged)。已提交表示数据已经安全的保存在本地数据库中，已修改表示修改了文件，但还没有保存到数据库中，已暂存表示对一个已修改的文件的当前版本做了标记，使其包含在下次提交的快照中。</p><h3 id="git工作区："><a href="#git工作区：" class="headerlink" title="git工作区："></a>git工作区：</h3><p><img src="https://img-blog.csdn.net/20180620160929791?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdteDE5OTMzMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>workspace: 工作区</p><p>index: 暂存区 【可以使用 git status来查看当前暂存区的状态】</p><p>repository： 本地仓库（仓库区）</p><p>remote：远程仓库</p><p>### </p><h3 id="git常用命令："><a href="#git常用命令：" class="headerlink" title="git常用命令："></a>git常用命令：</h3><p><img src="https://img-blog.csdn.net/20180620165443197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdteDE5OTMzMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="使用git进行项目管理"><a href="#使用git进行项目管理" class="headerlink" title="使用git进行项目管理"></a>使用git进行项目管理</h3><ol><li>克隆现有的仓库：</li></ol><p>git clone [url] (自定义仓库名)</p><ol start="2"><li>在现有的目录中初始化仓库</li></ol><p>git init</p><p>执行完上述命令后，创建一个名为.git的子目录，这个子目录中含有初始化Git仓库的所有必须文件，是git仓库的骨干，接下来实现跟踪文件并提交</p><p>git add. (或用文件名代替.)（git add. 表示将所有文件暂存）</p><p>git commit   // 提交</p><ol start="3"><li>更新提交到仓库</li></ol><p>使用git status 查看更改信息</p><p>查看具体修改的位置 使用 git diff,只显示尚未暂存的改动</p><ol start="4"><li>推送到远程仓库</li></ol><p>git push origin master</p><h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><ul><li><p>将Git的一个存储库克隆为工作副本。<br>可以通过添加/编辑文件修改工作副本。<br>如有必要，还可以通过让其他开发人员一起来更改/更新工作副本。<br>在提交之前查看更改。<br>提交更改：如果一切正常，那么将您的更改推送到存储库。</p></li><li><p>提交后，如果意识到某些错误并修改错误后，则将最后一个正确的修改提交并将推送到存储库。</p></li></ul><p>总结来说，git可以认为是一个软件，能够帮你更好的写程序，github则是一个网站，托管你的代码，这个网站可以帮助程序员之间互相交流和学习。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leading head ヾ(=･ω･=)o---❥(ゝω・✿ฺ)</title>
      <link href="/2019/03/01/Leading-head/"/>
      <url>/2019/03/01/Leading-head/</url>
      
        <content type="html"><![CDATA[<p>﻿ε≡٩(๑&gt;₃&lt;)۶ 一心向学…</p><p>φ(๑˃∀˂๑)♪ 学习是我的全部</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><em>:ஐ٩(๑´ᵕ`)۶ஐ:</em> 学习使我进步</p><p>*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><img src="https://ww2.sinaimg.cn/bmiddle/ba4957ffgy1g0m3t4sgbmj20k00k0jsv.jpg" alt="夹缝中生存"></p><h1 id="辅助"><a href="#辅助" class="headerlink" title="辅助"></a>辅助</h1><p>学习后端也需要一些前端知识，所以还是应该看一看</p><ul><li style="list-style: none"><input type="checkbox"> CSS：常见的各种属性 圆角属性 阴影属性 背景 HSLA色轮模式 浮动</li><li style="list-style: none"><input type="checkbox"> JS：JS的基本语法 数据类型 对象和常用对象 history对象 location对象 bom对象 表单对象 dom对象 window对象 常见事件 选项卡 、幻灯片、 贪吃蛇 、瀑布流各种特效</li><li style="list-style: none"><input type="checkbox"> jQuery </li><li style="list-style: none"><input type="checkbox"> ajax</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
            <tag> AJAX </tag>
            
            <tag> 前端开发栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Forever young, forever tearful. 念念不忘，必有回响···</title>
      <link href="/2019/02/28/first/"/>
      <url>/2019/02/28/first/</url>
      
        <content type="html"><![CDATA[<p>今天是2月28日，是二月的最后一天，本着对自己以及对自己负责的态度，建立了这个自己的小窝。从今天开始，真滴真滴要开始好好学习了GG，每天进步一点点，希望自己在这条发量越来越少的路上，学到越来越多的知识，不去理睬他人，切勿多管闲事，踏踏实实，做好寄几~</p><p>﻿ε≡٩(๑&gt;₃&lt;)۶ 一心向学…</p><p>φ(๑˃∀˂๑)♪ 学习是我的全部</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><em>:ஐ٩(๑´ᵕ`)۶ஐ:</em> 学习使我进步</p><p>*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</p><p><em>φ(❐</em>❐✧ 人丑就要多读书</p><p>(๑╹ヮ╹๑)ﾉ Studying makes me happy</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><img src="https://wx1.sinaimg.cn/mw690/006ZeP2Nly1fs3srqy9qjj305i02ya9v.jpg" alt="嘻嘻嘻"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>其实之前指定了一个计划的，当时还没有想好到底是从事前端还是后端，也没有想好要凭借哪个语言吃饭，指定的计划草包了写，什么都想学注定是什么也学不好的</p><p>现在看来Python暂时要放弃了，前端那些必备的知识还是不能放下</p><p>Java学起来好难路途遥远</p><p>算法还是太差，说好的剑指offer一般还没有刷完，难受</p><p>六级又没过…</p><p>好好休息…</p><p>好好努力…</p><p>减减肥…</p><p><img src="https://ww3.sinaimg.cn/bmiddle/0065Gvg5gy1g0lyllw5q4j30jg0huwik.jpg" alt="img"></p><p>设计模式</p><p>算法+数据结构</p><p>英语六级</p><p>Java框架</p><p>4.24</p><p>我又回来了嘻嘻嘻：）</p><p>分清主次很重要啊很重要</p><p>从头撸一遍吧，利用好碎片时间~~~~</p><p>“不要对未知的事情充满恐惧。”</p>]]></content>
      
      
      <categories>
          
          <category> ( • ̀ω•́ )✧寄几 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/02/27/hello-world/"/>
      <url>/2019/02/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

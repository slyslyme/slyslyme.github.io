<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java框架学习 ๑╹◡╹)ﾉ”  [spring]</title>
      <link href="/2019/03/10/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%5Bspring%5D1/"/>
      <url>/2019/03/10/Java%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%5Bspring%5D1/</url>
      
        <content type="html"><![CDATA[<p>Java框架学习之路</p><p><img src="https://ww4.sinaimg.cn/bmiddle/005yPOQzly1g0xhzgmagdj30u01hctwf.jpg" alt="img"></p><p>#### </p><h2 id="介绍spring"><a href="#介绍spring" class="headerlink" title="介绍spring"></a>介绍spring</h2><p>90.为什么要使用 spring？</p><p>91.解释一下什么是 aop？</p><p>92.解释一下什么是 ioc？</p><p>93.spring 有哪些主要模块？</p><p>94.spring 常用的注入方式有哪些？</p><p>95.spring 中的 bean 是线程安全的吗？</p><p>96.spring 支持几种 bean 的作用域？</p><p>97.spring 自动装配 bean 有哪些方式？</p><p>98.spring 事务实现方式有哪些？</p><p>99.说一下 spring 的事务隔离？</p><p>100.说一下 spring mvc 运行流程？</p><p>101.spring mvc 有哪些组件？</p><p>102.@RequestMapping 的作用是什么？</p><p>103.@Autowired 的作用是什么？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端学习✧(≖ ◡ ≖✿</title>
      <link href="/2019/03/09/Java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/03/09/Java%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>哦天哪 心动女生~~~~</p><p><img src="https://wx2.sinaimg.cn/mw690/006aNohggy1g0u4bqdhu6j30u0140wnj.jpg" alt="img"></p><h2 id="Java基础篇"><a href="#Java基础篇" class="headerlink" title="Java基础篇"></a>Java基础篇</h2><p>一、JDK和JRE有什么区别</p><p>JRE是Java程序的运行环境，核心内容是JVM和一些核心类库，主要面向程序使用者。</p><p>JDK是Java的开发工具包，包含各种类库和工具，主要面向开发人员，提供开发环境和运行环境。</p><p>二、 == 和equals的区别是什么</p><ol><li><p>== 比较内存地址的数值,也就是比较是否是同一个地址,即是否是同一个对象</p></li><li><p>equals通过重写用来比较两个字符串内容是否相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">String str3 = str2;</span><br><span class="line">System.out.println(str1==str2);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str1==str3);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str3==str2);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.</p></li><li><p>栈(stack)：存放<strong>基本类型的变量数据</strong>和<strong>对象的引用</strong>，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）</p></li><li>堆(heap)：存放所有<strong>new出来的对象</strong>。</li><li>静态域：存放静态成员（static定义的）。</li><li>常量池：存放字符串常量和基本类型常量（public static final），常量池位于堆中。</li><li>非RAM存储：硬盘等永久存储空间</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"china"</span>;  </span><br><span class="line">String s2 = <span class="string">"china"</span>;  </span><br><span class="line">String s3 = <span class="string">"china"</span>;  </span><br><span class="line">String ss1 = <span class="keyword">new</span> String(<span class="string">"china"</span>);  </span><br><span class="line">String ss2 = <span class="keyword">new</span> String(<span class="string">"china"</span>);  </span><br><span class="line">String ss3 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</span><br></pre></td></tr></table></figure><p>s1 s2 s2存在与栈中，ss1 ss2 ss3是new出来的对象，其对象的引用（即对象在堆内存中的地址）存在栈中，“china”这个常量存在与常量池中</p><p><img src="http://dl.iteye.com/upload/attachment/331454/3588b3c6-f37b-3d63-a48f-59134ea691d2.png" alt="img"></p><p>下黄色这3个箭头，对于通过new产生一个字符串（假设为”china”）时，会先去常量池中查找是否已经有了”china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。这也就是有道面试题：String s = new String(“china”);产生几个对象？一个或两个，如果常量池中原来没有”china”,就是两个。</p><p>对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。</p><p><strong>关于Java中的堆和栈：</strong></p><p>栈中的数据和堆中的数据销毁并不是同步的。每个方法在执行时都会建立自己的栈区，方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收才可以被销毁，这个是由JVM决定的。 </p><p>对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。</p><p>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享。</p><p>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>三、两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</p><p>不一定。反过来也是不一定的。</p><p>hashCode()是返回哈希码，是对象在哈希表中的索引</p><p>关于Java规范：</p><p>规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该 相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。<br>规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。</p><p>自己的理解：在哈希表中的键值对，键不同值可能相同，所以hashCode()相同，其对象并不一定相等。</p><p>四、final 在 java 中有什么作用？</p><p>final修饰的变量，变量的值不能被修改，是常量，在声明的同时需要进行初始化。final 修饰的类不允许进行继承。final修饰的方法不能被重写。</p><p>五、java 中的 Math.round(-1.5) 等于多少？</p><p>-1</p><p>参数的小数部分大于0.5或者小于0.5，在根据绝对值进行四舍五入，如果刚好等于0.5，则舍入到正无穷+∞方向。</p><p>比如Math.round(-1.5)=-1  Math.round(1.5)=2  Math.round(-1.4)=-1  Math.round(-1.6)=-2  Math.round(1.6)=2  </p><p>六、String 属于基础的数据类型吗？</p><p>不属于。</p><p>Java中基本的数据类型是int(32)  float(32)  double(64)  char(16)  byte(8)   boolean(1)   short(16)   long(64)</p><p>String在定义中是final类，属于引用数据类型，变量名指向存数据对象的内存地址。即变量名指向hash</p><p>七、java 中操作字符串都有哪些类？它们之间有什么区别？</p><p>String  stringBuffer stringBuilder</p><ol><li>String</li></ol><p>String 对象创建后则不能被修改，是<strong>不可变</strong>的，在定义中是<strong>final类</strong>，其对String操作的方法在定义中也是生成新的对象，所谓的修改其实是创建了新的对象，所指向的<strong>内存空间不同</strong>。</p><p><strong>注意</strong>：Object类中equal()方法比较的是对象的引用是否指向同一块内存地址，而String类中equals(): 比较存储在两个字符串对象中的内容是否一致。<strong>Object类中是equal()方法；String类中是equals()，差了一个s。</strong></p><p>String的操作是改变复制地址并不是改变值</p><ol start="2"><li>StringBuffer</li></ol><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。</p><p>　　　　<strong>char[] value;</strong></p><p>StringBuffer类的方法是多线程、安全的，而StringBuilder不是线程安全的，相比而言，StringBuilder类会略微快一点。<strong>对于经常要改变值的字符串应该使用StringBuffer和StringBuilder类。</strong></p><ol start="3"><li>StringBuilder</li></ol><p>单线程下使用stringBuilder效率更高</p><p>一般情况下执行效率： StringBuilder &gt; StringBuffer &gt; String</p><p>八、String str=”i”与 String str=new String(“i”)一样吗？</p><p>不一样。对于直接使用赋值法创建的字符串，如果内存常量池中已经为“i”分配了内存，那么str就指向”i“内存对象的地址。使用第二种new出来的字符串，不管常量池中有没有”i“都会在堆中重新分配一个内存区域来存放”i“，然后str指向它，相当于内存（堆）中有两个”i“,只是存放地址不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"hello world"</span>;</span><br><span class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">        String str3 = <span class="string">"hello world"</span>;</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">         </span><br><span class="line">        System.out.println(str1==str2);  <span class="comment">// false</span></span><br><span class="line">        System.out.println(str1==str3);  <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2==str4);  <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       关于JVM内存机制 ，在class文件中有一部分 来存储编译期间生成的 <strong>字面常量</strong>以及<strong>符号引用</strong>，这部分叫做class文件常量池，在运行期间对应着方法区的运行时<strong>常量池</strong>。</p><p>　　因此在上述代码中，String str1 = “hello world”;和String str3 = “hello world”; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量”hello world”被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时<strong>常量池查找是否存在相同的字面常量</strong>，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。</p><p>　　总所周知，通过<strong>new关键字来生成对象是在堆区</strong>进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello"</span>;</span><br><span class="line">        String b =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String c =  <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">        String d = b.intern();</span><br><span class="line">         </span><br><span class="line">        System.out.println(a==b); <span class="comment">// false</span></span><br><span class="line">        System.out.println(b==c); <span class="comment">// false</span></span><br><span class="line">        System.out.println(b==d); <span class="comment">// false</span></span><br><span class="line">        System.out.println(a==d); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。</p><p>九、如何将字符串反转</p><p>递归String left= s.substring(0, length/2); String right = s.substring(length / 2, length); return reverse1(right)+reverse1(left);  // 关于substring是截取函数</p><p>使用StringBuffer()中的reserve方法：new StringBuffer(s).reverse().toString();</p><p>分解字符串单个字符拼接/利用charAt（）</p><p>字符串首位对调位置</p><p>十、String类的常用方法有哪些</p><p>int .length() 字符串的长度</p><p>boolean .equals(String s) 比较字符串试题是否相等</p><p>int compareTo(String s)按照字典序和S进行比较大小，大于S返回正值</p><p>boolean contains(String s) 判断当前字符串对象是否含有s</p><p>int indexOf(String s) 返回位置索引，没有就返回负数</p><p>String trim() 去掉字符串前后空格</p><p>String substring(int start, int end) 返回子串</p><p>基本数据类型的相互转化：</p><p>int parseInt(String s)  或者short long Float等</p><p>对象的字符串表示：</p><p>String toString()  可以对这个方法进行重写</p><p>StringBuffer类，创建的是可修改的字符串序列，可以使用append进行追加</p><p>char charAt(int n) 得到参数n位置上的单个字符</p><p>void setCharAt(int n, char ch) 将N处的字符串进行替换</p><p>十一、抽象类必须要有抽象方法吗？</p><p>不是必须的。抽象类和普通类相比就是多了抽象方法， 抽象类中可以没有抽象方法，但是抽象方法一定要在抽象类中。抽象类不能使用new运算符创建对象。如果一个非抽象类是抽象类的子类，那么他一定要重写父类的抽象方法，给出方法，所以不能用final 和static同时修饰一个方法。</p><p>十二、普通类和抽象类有哪些区别？</p><ol><li>抽象类不能被实例化（不能用new创建对象）需要进行重写</li><li>抽象类中可以有抽象方法</li><li>抽象类中的抽象方法没有方法体</li><li>抽象类的非抽象子类必须重写抽象类的全部抽象方法，如果没有，那么子类也必须定义为抽象类</li></ol><p>十三、抽象类能使用 final 修饰吗？</p><p>不能，final修饰的类无法继承</p><p>十四、接口和抽象类有什么区别？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式【One design pattern a day】 (o(*ﾟ▽ﾟ*)o)♡</title>
      <link href="/2019/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%90One-design-pattern-a-day%E3%80%91-(o(%EF%BE%9F%E2%96%BD%EF%BE%9F)o)%E2%99%A1/"/>
      <url>/2019/03/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%90One-design-pattern-a-day%E3%80%91-(o(%EF%BE%9F%E2%96%BD%EF%BE%9F)o)%E2%99%A1/</url>
      
        <content type="html"><![CDATA[<p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p>介个设计模式是上个学期实验室大神建议看的，结果拖着又懒一直没看，一天一个给补上吧吼吼~~</p><ol><li>工厂模式 池子 连接池</li><li>单例模式  饿汉模式 懒汉模式</li><li>适配器模式 过滤器 装饰器 （Java Web)</li><li>迭代器</li><li>模板模式 </li><li>状态模式</li><li>MVC （model模型 数据层     view视图层 渲染界面  coltroller 控制器 业务逻辑）</li></ol><p><img src="https://ww3.sinaimg.cn/bmiddle/007Bs6V5ly1g0o7v6j0ypj30b40b4t9h.jpg" alt="img"></p><h2 id="前言-what-is-the-设计模式"><a href="#前言-what-is-the-设计模式" class="headerlink" title="前言-what is the 设计模式"></a>前言-what is the 设计模式</h2><p>1.设计模式是解决方案</p><p>2.设计模式是特定问题的解决方案</p><p>3.设计模式是重复出现的、特定问题的解决方案</p><p>4.设计模式是用于解决在特定环境下、重复出现的、特定问题的解决方案</p><p>5.设计模式是经过验证的，用于解决在特定环境下、重复出现的、特定问题的解决方案</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><a href="http://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">参考学习</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git总结   ฅ^•ﻌ•^ฅ</title>
      <link href="/2019/03/02/git%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/02/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>﻿ε≡٩(๑&gt;₃&lt;)۶ 一心向学…</p><p>φ(๑˃∀˂๑)♪ 学习是我的全部</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><em>:ஐ٩(๑´ᵕ`)۶ஐ:</em> 学习使我进步</p><p>*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p>今天是三月二号嘤~ </p><p>总结一下git的工作原理，以及使用git的基本命令</p><p><img src="https://ww3.sinaimg.cn/thumb150/006tKWBYgy1g0nqzo2ipdj30b40b4jrz.jpg" alt="img"></p><p><img src="https://ww1.sinaimg.cn/bmiddle/0071folOly1g0njusl3kuj31731734ee.jpg" alt="你只配看本学霸背影"></p><h1 id="Git猫粮"><a href="#Git猫粮" class="headerlink" title="Git猫粮"></a>Git猫粮</h1><p>有git使用经验，并对git工作流程有所了解.</p><h3 id="什么是版本控制系统："><a href="#什么是版本控制系统：" class="headerlink" title="什么是版本控制系统："></a>什么是版本控制系统：</h3><p>维基百科的解释：版本控制（Revision control）是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软体工程技巧，借此能在软体开发的过程中，确保由不同人所编辑的同一程式档案都得到同步。</p><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h3 id="git与其他版本版本控制系统的差异："><a href="#git与其他版本版本控制系统的差异：" class="headerlink" title="git与其他版本版本控制系统的差异："></a>git与其他版本版本控制系统的差异：</h3><p>CVS Subversion Perforce Bazaar等系统以文件变更列表的方式存储信息，这类系统保存的信息看作是一组基本文件和每个文件随时间逐步积累的差异。存储每个文件与原始版本的差异。</p><p>Git主要是对当时的全部文件制作一个快照并保存这个快照的索引。如果文件没有修改，git不再重新存储该文件，而只是保留一个链接指向之前存储的文件。Git更像是把数据看作是对小型文件系统的一组快照</p><h3 id="git的三种状态："><a href="#git的三种状态：" class="headerlink" title="git的三种状态："></a>git的三种状态：</h3><p>Git 有三种状态：已提交(committed)、已修改(modified)和已暂存(staged)。已提交表示数据已经安全的保存在本地数据库中，已修改表示修改了文件，但还没有保存到数据库中，已暂存表示对一个已修改的文件的当前版本做了标记，使其包含在下次提交的快照中。</p><h3 id="git工作区："><a href="#git工作区：" class="headerlink" title="git工作区："></a>git工作区：</h3><p><img src="https://img-blog.csdn.net/20180620160929791?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdteDE5OTMzMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>workspace: 工作区</p><p>index: 暂存区 【可以使用 git status来查看当前暂存区的状态】</p><p>repository： 本地仓库（仓库区）</p><p>remote：远程仓库</p><p>### </p><h3 id="git常用命令："><a href="#git常用命令：" class="headerlink" title="git常用命令："></a>git常用命令：</h3><p><img src="https://img-blog.csdn.net/20180620165443197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdteDE5OTMzMjg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h3 id="使用git进行项目管理"><a href="#使用git进行项目管理" class="headerlink" title="使用git进行项目管理"></a>使用git进行项目管理</h3><ol><li>克隆现有的仓库：</li></ol><p>git clone [url] (自定义仓库名)</p><ol start="2"><li>在现有的目录中初始化仓库</li></ol><p>git init</p><p>执行完上述命令后，创建一个名为.git的子目录，这个子目录中含有初始化Git仓库的所有必须文件，是git仓库的骨干，接下来实现跟踪文件并提交</p><p>git add. (或用文件名代替.)（git add. 表示将所有文件暂存）</p><p>git commit   // 提交</p><ol start="3"><li>更新提交到仓库</li></ol><p>使用git status 查看更改信息</p><p>查看具体修改的位置 使用 git diff,只显示尚未暂存的改动</p><ol start="4"><li>推送到远程仓库</li></ol><p>git push origin master</p><h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><ul><li><p>将Git的一个存储库克隆为工作副本。<br>可以通过添加/编辑文件修改工作副本。<br>如有必要，还可以通过让其他开发人员一起来更改/更新工作副本。<br>在提交之前查看更改。<br>提交更改：如果一切正常，那么将您的更改推送到存储库。</p></li><li><p>提交后，如果意识到某些错误并修改错误后，则将最后一个正确的修改提交并将推送到存储库。</p></li></ul><p>总结来说，git可以认为是一个软件，能够帮你更好的写程序，github则是一个网站，托管你的代码，这个网站可以帮助程序员之间互相交流和学习。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leading head ヾ(=･ω･=)o---❥(ゝω・✿ฺ)</title>
      <link href="/2019/03/01/Leading-head/"/>
      <url>/2019/03/01/Leading-head/</url>
      
        <content type="html"><![CDATA[<p>﻿ε≡٩(๑&gt;₃&lt;)۶ 一心向学…</p><p>φ(๑˃∀˂๑)♪ 学习是我的全部</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><em>:ஐ٩(๑´ᵕ`)۶ஐ:</em> 学习使我进步</p><p>*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><img src="https://ww2.sinaimg.cn/bmiddle/ba4957ffgy1g0m3t4sgbmj20k00k0jsv.jpg" alt="夹缝中生存"></p><h1 id="必需猫粮"><a href="#必需猫粮" class="headerlink" title="必需猫粮"></a>必需猫粮</h1><h3 id="职位描述：（Most-important信息安全部）"><a href="#职位描述：（Most-important信息安全部）" class="headerlink" title="职位描述：（Most important信息安全部）"></a><strong>职位描述：</strong>（Most important信息安全部）</h3><p>1.公司内部支持系统以及B2B的服务及数据展示平台的开发及维护。涉及到的产品为PC端为主，但也会有部分多端支持的项目，包括但不限于手机端、app、微信公众号、活动H5页面等等;<br>2.较好的沟通能力，和产品经理、业务方、设计师、后端开发等配合产出高可用性的产品，对业务进行分析并提出自己的看法和建议;<br>3.参与到项目架构与选型过程，并需要主动和同事交流各类技术和问题.</p><p><strong>任职要求：</strong></p><p>1.计算机或软件工程相关专业毕业，具有基础计算机软件知识;<br>2.精通 HTML5、CSS3、以及JavaScript，熟悉Web API有了解;<br>3.有Vue、React、或Angular使用经验者优先;<br>4.熟悉各种前端调试工具和手段、如Charles、Fiddler等等，并具有问题分析能力;<br>5.对前端常用技术和工具有所了解，包括Nginx、Linux、Webpack等;<br>6.有git使用经验，并对git工作流程有所了解.</p><h3 id="任职要求：（web平台）"><a href="#任职要求：（web平台）" class="headerlink" title="任职要求：（web平台）"></a><strong>任职要求：</strong>（web平台）</h3><p>1.了解HTML5/CSS3/JavaScript相关技能，有一定的项目实践经验;<br>2.有一定的JavaScript编写能力，能够使用原生JavaScript实现复杂功能和UI模块;</p><p>3.了解Web标准，熟悉浏览器规范和兼容性;<br>4.熟悉React/Vue 等技术栈，了解 Node.js 知识;<br>5.视野开阔，心态开放，对新技术有较高热情;<br>6.良好的沟通能力，较强的责任心.</p><h3 id="任职要求：（搜索）"><a href="#任职要求：（搜索）" class="headerlink" title="任职要求：（搜索）"></a><strong>任职要求：</strong>（搜索）</h3><p>1.精通HTML/XHTML、CSS等网页制作技术，熟悉页面架构和布局，掌握原生Javascript也会Js的一些开源框架<br>2.熟悉W3C标准，对表现与数据分离、Web语义化等有深刻理解<br>3.对互联网产品和Web技术有强烈兴趣，有优秀的学习能力和强烈的进取心<br>4.具有良好的沟通能力和团队合作精神、优秀的分析问题和解决问题的能力 </p><p>具有以下能力者优先考虑：<br>1.具有Mobile WEB/WAP、HTML5/CSS3、nodes、Flash等开发经验<br>2.熟悉Linux平台，掌握一种后端开发语言（PHP/Java/C/C++/python等）<br>3.使用过一些开源的框架做过项目<br>4.具有一定的软件工程意识，对数据结构和算法设计有充分理解</p><h3 id="任职要求：-智慧城市"><a href="#任职要求：-智慧城市" class="headerlink" title="任职要求：(智慧城市)"></a><strong>任职要求：</strong>(智慧城市)</h3><p>1.统招本科或研究生在读，计算机或软件等相关专业；<br>2.熟悉Web应用开发，有实际项目或竞赛经验者优先；<br>3.熟悉linux，能熟练应用一门或几门以下语言：Python/Java/Php/Nodejs等；<br>4.熟悉Web前端技术（HTML、CSS、JavaScript等），并对前后端协作有深入理解；<br>5.熟悉MySql数据库设计和优化，熟悉常用的消息队列、缓存、负载均衡等中间件技术；<br>6.熟悉Redis，memcache等nosql数据存储；<br>7.熟悉HTTP、TCP/IP网络协议.<br>8、良好的沟通交流能力，有较强的独立解决问题、自主学习的能力，能快速熟悉并掌握新技术。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Forever young, forever tearful. 念念不忘，必有回响···</title>
      <link href="/2019/02/28/first/"/>
      <url>/2019/02/28/first/</url>
      
        <content type="html"><![CDATA[<p>今天是2月28日，是二月的最后一天，本着对自己以及对自己负责的态度，建立了这个自己的小窝。从今天开始，真滴真滴要开始好好学习了GG，每天进步一点点，希望自己在这条发量越来越少的路上，学到越来越多的知识，不去理睬他人，切勿多管闲事，踏踏实实，做好寄几~</p><p>﻿ε≡٩(๑&gt;₃&lt;)۶ 一心向学…</p><p>φ(๑˃∀˂๑)♪ 学习是我的全部</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><em>:ஐ٩(๑´ᵕ`)۶ஐ:</em> 学习使我进步</p><p>*✧⁺˚⁺ପ(๑･ω･)੭ु⁾⁾ 好好学习天天向上</p><p><em>φ(❐</em>❐✧ 人丑就要多读书</p><p>(๑╹ヮ╹๑)ﾉ Studying makes me happy</p><p>(っ•̀ω•́)っ✎⁾⁾ 我爱学习</p><p><img src="https://wx1.sinaimg.cn/mw690/006ZeP2Nly1fs3srqy9qjj305i02ya9v.jpg" alt="嘻嘻嘻"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>先做个计划吧：</p><table><thead><tr><th>周一</th><th>周二</th><th>周三</th><th>周四</th><th>周五</th><th>周六</th><th>周日</th></tr></thead><tbody><tr><td>Java</td><td>Django</td><td>Java</td><td>Java</td><td>Java</td><td>Java</td><td>Django</td></tr><tr><td>Java</td><td>Django</td><td>JS</td><td>Java</td><td>Django</td><td>实验室/JS</td><td>实验室/JS</td></tr><tr><td>六级/数据结构</td><td>六级/数据结构</td><td>六级/数据结构</td><td>六级/数据结构</td><td>六级/数据结构</td><td>六级/数据结构</td><td>六级/数据结构</td></tr></tbody></table><p>空余时间还是读读书吧…</p><p>六级又没过…</p><p>好好休息…</p><p>好好努力…</p><p>减减肥…</p><p><img src="https://ww3.sinaimg.cn/bmiddle/0065Gvg5gy1g0lyllw5q4j30jg0huwik.jpg" alt="img"></p><p>设计模式</p><p>算法+数据结构</p><p>英语六级</p><p>Java框架</p><p>leading head</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/02/27/hello-world/"/>
      <url>/2019/02/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
